{"content":"<h2 id=\"什么是-http-协议\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#什么是-http-协议\"><span>什么是 HTTP 协议</span></a></h2>\n<p>HTTP 协议全称 Hyper Text Transfer Protocol，翻译过来就是超文本传输协议，位于 TCP/IP 四层模型当中的应用层。</p>\n<figure><img src=\"@source/code/website/definition/assets/http1.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>HTTP 协议通过 <strong>请求/响应</strong> 的方式，在客户端和服务端之间进行通信。</p>\n<figure><img src=\"@source/code/website/definition/assets/http2.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>这一切看起来很美好，但是 HTTP 协议有一个致命的缺点: <strong>不够安全</strong>。</p>\n<p>HTTP 协议的信息传输完全以明文方式，不做任何加密，相当于是在网络上“裸奔”。这样会导致什么问题呢? 让我们打一个比方:</p>\n<p>小灰是客户端，小灰的同事小红是服务端，有一天小灰试图给小红发送请求。</p>\n<figure><img src=\"@source/code/website/definition/assets/http3.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>但是，由于传输信息是明文，这个信息有可能被某个中间人恶意截获甚至篡改。这种行为叫做<strong>中间人攻击</strong>。</p>\n<figure><img src=\"@source/code/website/definition/assets/http4.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http5.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http6.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>如何进行加密呢?</p>\n<p>小灰和小红可以事先约定一种<strong>对称加密</strong>方式，并且约定一个随机生成的密钥。后续的通信中，信息发送方都使用密钥对信息加密，而信息接收方通过同样的密钥对信息解密。</p>\n<figure><img src=\"@source/code/website/definition/assets/http7.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http8.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>这样做是不是就绝对安全了呢? 并不是。</p>\n<p>虽然我们在后续的通信中对明文进行了加密，但是第一次约定加密方式和密钥的通信仍然是明文，如果第一次通信就已经被拦截了，那么密钥就会泄露给中间人，中间人仍然可以解密后续所有的通信内容。</p>\n<figure><img src=\"@source/code/website/definition/assets/http9.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>这可怎么办呢? 别担心，我们可以使用<strong>非对称加密</strong>，为密钥的传输做一层额外的保护。</p>\n<p>非对称加密的一组秘钥对中，包含一个公钥和一个私钥。明文既可以用公钥加密，用私钥解密；也可以用私钥加密，用公钥解密。</p>\n<p>在小灰和小红建立通信的时候，小红首先把自己的公钥 Key1 发给小灰:</p>\n<figure><img src=\"@source/code/website/definition/assets/http10.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>收到小红的公钥以后，小灰自己生成一个用于对称加密的密钥 Key2，并且用刚才接收的公钥 Key1 对 Key2 进行加密(这里有点绕)，发送给小红:</p>\n<figure><img src=\"@source/code/website/definition/assets/http11.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>小红利用自己非对称加密的私钥，解开了公钥 Key1 的加密，获得了 Key2 的内容。从此以后，两人就可以利用 Key2 进行对称加密的通信了。</p>\n<figure><img src=\"@source/code/website/definition/assets/http12.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>在通信过程中，即使中间人在一开始就截获了公钥 Key1，由于不知道私钥是什么，也无从解密。</p>\n<figure><img src=\"@source/code/website/definition/assets/http13.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http14.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>是什么坏主意呢? 中间人虽然不知道小红的私钥是什么，但是在截获了小红的公钥 Key1 之后，却可以偷天换日，自己另外生成一对公钥私钥，把自己的公钥 Key3 发送给小灰。</p>\n<figure><img src=\"@source/code/website/definition/assets/http15.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>小灰不知道公钥被偷偷换过，以为 Key3 就是小红的公钥。于是按照先前的流程，用 Key3 加密了自己生成的对称加密密钥 Key2，发送给小红。</p>\n<p>这一次通信再次被中间人截获，中间人先用自己的私钥解开了 Key3 的加密，获得 Key2，然后再用当初小红发来的 Key1 重新加密，再发给小红。</p>\n<figure><img src=\"@source/code/website/definition/assets/http16.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>这样一来，两个人后续的通信尽管用 Key2 做了对称加密，但是中间人已经掌握了 Key2，所以可以轻松进行解密。</p>\n<figure><img src=\"@source/code/website/definition/assets/http17.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http18.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>是什么解决方案呢? 难道再把公钥进行一次加密吗? 这样只会陷入鸡生蛋蛋生鸡，永无止境的困局。</p>\n<p>这时候，我们有必要引入第三方，一个权威的证书颁发机构(CA)来解决。</p>\n<p>到底什么是证书呢? 证书包含如下信息:</p>\n<figure><img src=\"@source/code/website/definition/assets/http19.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>为了便于说明，我们这里做了简化，只列出了一些关键信息。至于这些证书信息的用处，我们看看具体的通信流程就能够弄明白了。</p>\n<p>流程如下:</p>\n<ol>\n<li>\n<p>作为服务端的小红，首先把自己的公钥发给证书颁发机构，向证书颁发机构申请证书。</p>\n<figure><img src=\"@source/code/website/definition/assets/http20.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n</li>\n<li>\n<p>证书颁发机构自己也有一对公钥私钥。机构利用自己的私钥来加密 Key1，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过机构的私钥加密。证书制作完成后，机构把证书发送给了服务端小红。</p>\n<figure><img src=\"@source/code/website/definition/assets/http21.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n</li>\n<li>\n<p>当小灰向小红请求通信的时候，小红不再直接返回自己的公钥，而是把自己申请的证书返回给小灰。</p>\n<figure><img src=\"@source/code/website/definition/assets/http22.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n</li>\n<li>\n<p>小灰收到证书以后，要做的第一件事情是验证证书的真伪。需要说明的是，各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥。所以小灰只需要知道是</p>\n<p>哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书签名。</p>\n<p>接下来，小灰按照同样的签名规则，自己也生成一个证书签名，如果两个签名一致，说明证书是有效的。</p>\n<p>验证成功后，小灰就可以放心地再次利用机构公钥，解密出服务端小红的公钥 Key1。</p>\n<figure><img src=\"@source/code/website/definition/assets/http23.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n</li>\n<li>\n<p>像之前一样，小灰生成自己的对称加密密钥 Key2，并且用服务端公钥 Key1 加密 Key2，发送给小红。</p>\n<figure><img src=\"@source/code/website/definition/assets/http24.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n</li>\n<li>\n<p>最后，小红用自己的私钥解开加密，得到对称加密密钥 Key2。于是两人开始用 Key2 进行对称加密的通信。</p>\n<figure><img src=\"@source/code/website/definition/assets/http25.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n</li>\n</ol>\n<p>在这样的流程下，我们不妨想一想，中间人是否还具有使坏的空间呢?</p>\n<figure><img src=\"@source/code/website/definition/assets/http26.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http27.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http28.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http29.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http30.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http31.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http32.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<div class=\"hint-container info\">\n<p class=\"hint-container-title\">相关信息</p>\n<p>最新推出的 TLS 协议，是 SSL 3.0 协议的升级版，和 SSL 协议的大体原理是相同的。</p>\n</div>\n","env":{"base":"/","filePath":"/Users/carson/Desktop/Mister-Hope.github.io-main/src/code/website/definition/https.md","filePathRelative":"code/website/definition/https.md","frontmatter":{"title":"Http 与 Https 介绍","icon":"http","date":"2019-11-03T00:00:00.000Z","author":"小灰","copyright":"本文转载自<a href=\"https://zhuanlan.zhihu.com/p/57142784\">小灰的知乎专栏</a>","next":"../../vue/"},"sfcBlocks":{"template":{"type":"template","content":"<template><h2 id=\"什么是-http-协议\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#什么是-http-协议\"><span>什么是 HTTP 协议</span></a></h2>\n<p>HTTP 协议全称 Hyper Text Transfer Protocol，翻译过来就是超文本传输协议，位于 TCP/IP 四层模型当中的应用层。</p>\n<figure><img src=\"@source/code/website/definition/assets/http1.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>HTTP 协议通过 <strong>请求/响应</strong> 的方式，在客户端和服务端之间进行通信。</p>\n<figure><img src=\"@source/code/website/definition/assets/http2.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>这一切看起来很美好，但是 HTTP 协议有一个致命的缺点: <strong>不够安全</strong>。</p>\n<p>HTTP 协议的信息传输完全以明文方式，不做任何加密，相当于是在网络上“裸奔”。这样会导致什么问题呢? 让我们打一个比方:</p>\n<p>小灰是客户端，小灰的同事小红是服务端，有一天小灰试图给小红发送请求。</p>\n<figure><img src=\"@source/code/website/definition/assets/http3.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>但是，由于传输信息是明文，这个信息有可能被某个中间人恶意截获甚至篡改。这种行为叫做<strong>中间人攻击</strong>。</p>\n<figure><img src=\"@source/code/website/definition/assets/http4.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http5.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http6.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>如何进行加密呢?</p>\n<p>小灰和小红可以事先约定一种<strong>对称加密</strong>方式，并且约定一个随机生成的密钥。后续的通信中，信息发送方都使用密钥对信息加密，而信息接收方通过同样的密钥对信息解密。</p>\n<figure><img src=\"@source/code/website/definition/assets/http7.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http8.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>这样做是不是就绝对安全了呢? 并不是。</p>\n<p>虽然我们在后续的通信中对明文进行了加密，但是第一次约定加密方式和密钥的通信仍然是明文，如果第一次通信就已经被拦截了，那么密钥就会泄露给中间人，中间人仍然可以解密后续所有的通信内容。</p>\n<figure><img src=\"@source/code/website/definition/assets/http9.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>这可怎么办呢? 别担心，我们可以使用<strong>非对称加密</strong>，为密钥的传输做一层额外的保护。</p>\n<p>非对称加密的一组秘钥对中，包含一个公钥和一个私钥。明文既可以用公钥加密，用私钥解密；也可以用私钥加密，用公钥解密。</p>\n<p>在小灰和小红建立通信的时候，小红首先把自己的公钥 Key1 发给小灰:</p>\n<figure><img src=\"@source/code/website/definition/assets/http10.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>收到小红的公钥以后，小灰自己生成一个用于对称加密的密钥 Key2，并且用刚才接收的公钥 Key1 对 Key2 进行加密(这里有点绕)，发送给小红:</p>\n<figure><img src=\"@source/code/website/definition/assets/http11.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>小红利用自己非对称加密的私钥，解开了公钥 Key1 的加密，获得了 Key2 的内容。从此以后，两人就可以利用 Key2 进行对称加密的通信了。</p>\n<figure><img src=\"@source/code/website/definition/assets/http12.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>在通信过程中，即使中间人在一开始就截获了公钥 Key1，由于不知道私钥是什么，也无从解密。</p>\n<figure><img src=\"@source/code/website/definition/assets/http13.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http14.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>是什么坏主意呢? 中间人虽然不知道小红的私钥是什么，但是在截获了小红的公钥 Key1 之后，却可以偷天换日，自己另外生成一对公钥私钥，把自己的公钥 Key3 发送给小灰。</p>\n<figure><img src=\"@source/code/website/definition/assets/http15.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>小灰不知道公钥被偷偷换过，以为 Key3 就是小红的公钥。于是按照先前的流程，用 Key3 加密了自己生成的对称加密密钥 Key2，发送给小红。</p>\n<p>这一次通信再次被中间人截获，中间人先用自己的私钥解开了 Key3 的加密，获得 Key2，然后再用当初小红发来的 Key1 重新加密，再发给小红。</p>\n<figure><img src=\"@source/code/website/definition/assets/http16.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>这样一来，两个人后续的通信尽管用 Key2 做了对称加密，但是中间人已经掌握了 Key2，所以可以轻松进行解密。</p>\n<figure><img src=\"@source/code/website/definition/assets/http17.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http18.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>是什么解决方案呢? 难道再把公钥进行一次加密吗? 这样只会陷入鸡生蛋蛋生鸡，永无止境的困局。</p>\n<p>这时候，我们有必要引入第三方，一个权威的证书颁发机构(CA)来解决。</p>\n<p>到底什么是证书呢? 证书包含如下信息:</p>\n<figure><img src=\"@source/code/website/definition/assets/http19.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>为了便于说明，我们这里做了简化，只列出了一些关键信息。至于这些证书信息的用处，我们看看具体的通信流程就能够弄明白了。</p>\n<p>流程如下:</p>\n<ol>\n<li>\n<p>作为服务端的小红，首先把自己的公钥发给证书颁发机构，向证书颁发机构申请证书。</p>\n<figure><img src=\"@source/code/website/definition/assets/http20.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n</li>\n<li>\n<p>证书颁发机构自己也有一对公钥私钥。机构利用自己的私钥来加密 Key1，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过机构的私钥加密。证书制作完成后，机构把证书发送给了服务端小红。</p>\n<figure><img src=\"@source/code/website/definition/assets/http21.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n</li>\n<li>\n<p>当小灰向小红请求通信的时候，小红不再直接返回自己的公钥，而是把自己申请的证书返回给小灰。</p>\n<figure><img src=\"@source/code/website/definition/assets/http22.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n</li>\n<li>\n<p>小灰收到证书以后，要做的第一件事情是验证证书的真伪。需要说明的是，各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥。所以小灰只需要知道是</p>\n<p>哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书签名。</p>\n<p>接下来，小灰按照同样的签名规则，自己也生成一个证书签名，如果两个签名一致，说明证书是有效的。</p>\n<p>验证成功后，小灰就可以放心地再次利用机构公钥，解密出服务端小红的公钥 Key1。</p>\n<figure><img src=\"@source/code/website/definition/assets/http23.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n</li>\n<li>\n<p>像之前一样，小灰生成自己的对称加密密钥 Key2，并且用服务端公钥 Key1 加密 Key2，发送给小红。</p>\n<figure><img src=\"@source/code/website/definition/assets/http24.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n</li>\n<li>\n<p>最后，小红用自己的私钥解开加密，得到对称加密密钥 Key2。于是两人开始用 Key2 进行对称加密的通信。</p>\n<figure><img src=\"@source/code/website/definition/assets/http25.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n</li>\n</ol>\n<p>在这样的流程下，我们不妨想一想，中间人是否还具有使坏的空间呢?</p>\n<figure><img src=\"@source/code/website/definition/assets/http26.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http27.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http28.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http29.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http30.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http31.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http32.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<div class=\"hint-container info\">\n<p class=\"hint-container-title\">相关信息</p>\n<p>最新推出的 TLS 协议，是 SSL 3.0 协议的升级版，和 SSL 协议的大体原理是相同的。</p>\n</div>\n</template>","contentStripped":"<h2 id=\"什么是-http-协议\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#什么是-http-协议\"><span>什么是 HTTP 协议</span></a></h2>\n<p>HTTP 协议全称 Hyper Text Transfer Protocol，翻译过来就是超文本传输协议，位于 TCP/IP 四层模型当中的应用层。</p>\n<figure><img src=\"@source/code/website/definition/assets/http1.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>HTTP 协议通过 <strong>请求/响应</strong> 的方式，在客户端和服务端之间进行通信。</p>\n<figure><img src=\"@source/code/website/definition/assets/http2.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>这一切看起来很美好，但是 HTTP 协议有一个致命的缺点: <strong>不够安全</strong>。</p>\n<p>HTTP 协议的信息传输完全以明文方式，不做任何加密，相当于是在网络上“裸奔”。这样会导致什么问题呢? 让我们打一个比方:</p>\n<p>小灰是客户端，小灰的同事小红是服务端，有一天小灰试图给小红发送请求。</p>\n<figure><img src=\"@source/code/website/definition/assets/http3.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>但是，由于传输信息是明文，这个信息有可能被某个中间人恶意截获甚至篡改。这种行为叫做<strong>中间人攻击</strong>。</p>\n<figure><img src=\"@source/code/website/definition/assets/http4.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http5.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http6.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>如何进行加密呢?</p>\n<p>小灰和小红可以事先约定一种<strong>对称加密</strong>方式，并且约定一个随机生成的密钥。后续的通信中，信息发送方都使用密钥对信息加密，而信息接收方通过同样的密钥对信息解密。</p>\n<figure><img src=\"@source/code/website/definition/assets/http7.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http8.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>这样做是不是就绝对安全了呢? 并不是。</p>\n<p>虽然我们在后续的通信中对明文进行了加密，但是第一次约定加密方式和密钥的通信仍然是明文，如果第一次通信就已经被拦截了，那么密钥就会泄露给中间人，中间人仍然可以解密后续所有的通信内容。</p>\n<figure><img src=\"@source/code/website/definition/assets/http9.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>这可怎么办呢? 别担心，我们可以使用<strong>非对称加密</strong>，为密钥的传输做一层额外的保护。</p>\n<p>非对称加密的一组秘钥对中，包含一个公钥和一个私钥。明文既可以用公钥加密，用私钥解密；也可以用私钥加密，用公钥解密。</p>\n<p>在小灰和小红建立通信的时候，小红首先把自己的公钥 Key1 发给小灰:</p>\n<figure><img src=\"@source/code/website/definition/assets/http10.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>收到小红的公钥以后，小灰自己生成一个用于对称加密的密钥 Key2，并且用刚才接收的公钥 Key1 对 Key2 进行加密(这里有点绕)，发送给小红:</p>\n<figure><img src=\"@source/code/website/definition/assets/http11.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>小红利用自己非对称加密的私钥，解开了公钥 Key1 的加密，获得了 Key2 的内容。从此以后，两人就可以利用 Key2 进行对称加密的通信了。</p>\n<figure><img src=\"@source/code/website/definition/assets/http12.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>在通信过程中，即使中间人在一开始就截获了公钥 Key1，由于不知道私钥是什么，也无从解密。</p>\n<figure><img src=\"@source/code/website/definition/assets/http13.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http14.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>是什么坏主意呢? 中间人虽然不知道小红的私钥是什么，但是在截获了小红的公钥 Key1 之后，却可以偷天换日，自己另外生成一对公钥私钥，把自己的公钥 Key3 发送给小灰。</p>\n<figure><img src=\"@source/code/website/definition/assets/http15.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>小灰不知道公钥被偷偷换过，以为 Key3 就是小红的公钥。于是按照先前的流程，用 Key3 加密了自己生成的对称加密密钥 Key2，发送给小红。</p>\n<p>这一次通信再次被中间人截获，中间人先用自己的私钥解开了 Key3 的加密，获得 Key2，然后再用当初小红发来的 Key1 重新加密，再发给小红。</p>\n<figure><img src=\"@source/code/website/definition/assets/http16.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>这样一来，两个人后续的通信尽管用 Key2 做了对称加密，但是中间人已经掌握了 Key2，所以可以轻松进行解密。</p>\n<figure><img src=\"@source/code/website/definition/assets/http17.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http18.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>是什么解决方案呢? 难道再把公钥进行一次加密吗? 这样只会陷入鸡生蛋蛋生鸡，永无止境的困局。</p>\n<p>这时候，我们有必要引入第三方，一个权威的证书颁发机构(CA)来解决。</p>\n<p>到底什么是证书呢? 证书包含如下信息:</p>\n<figure><img src=\"@source/code/website/definition/assets/http19.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<p>为了便于说明，我们这里做了简化，只列出了一些关键信息。至于这些证书信息的用处，我们看看具体的通信流程就能够弄明白了。</p>\n<p>流程如下:</p>\n<ol>\n<li>\n<p>作为服务端的小红，首先把自己的公钥发给证书颁发机构，向证书颁发机构申请证书。</p>\n<figure><img src=\"@source/code/website/definition/assets/http20.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n</li>\n<li>\n<p>证书颁发机构自己也有一对公钥私钥。机构利用自己的私钥来加密 Key1，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过机构的私钥加密。证书制作完成后，机构把证书发送给了服务端小红。</p>\n<figure><img src=\"@source/code/website/definition/assets/http21.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n</li>\n<li>\n<p>当小灰向小红请求通信的时候，小红不再直接返回自己的公钥，而是把自己申请的证书返回给小灰。</p>\n<figure><img src=\"@source/code/website/definition/assets/http22.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n</li>\n<li>\n<p>小灰收到证书以后，要做的第一件事情是验证证书的真伪。需要说明的是，各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥。所以小灰只需要知道是</p>\n<p>哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书签名。</p>\n<p>接下来，小灰按照同样的签名规则，自己也生成一个证书签名，如果两个签名一致，说明证书是有效的。</p>\n<p>验证成功后，小灰就可以放心地再次利用机构公钥，解密出服务端小红的公钥 Key1。</p>\n<figure><img src=\"@source/code/website/definition/assets/http23.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n</li>\n<li>\n<p>像之前一样，小灰生成自己的对称加密密钥 Key2，并且用服务端公钥 Key1 加密 Key2，发送给小红。</p>\n<figure><img src=\"@source/code/website/definition/assets/http24.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n</li>\n<li>\n<p>最后，小红用自己的私钥解开加密，得到对称加密密钥 Key2。于是两人开始用 Key2 进行对称加密的通信。</p>\n<figure><img src=\"@source/code/website/definition/assets/http25.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n</li>\n</ol>\n<p>在这样的流程下，我们不妨想一想，中间人是否还具有使坏的空间呢?</p>\n<figure><img src=\"@source/code/website/definition/assets/http26.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http27.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http28.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http29.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http30.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http31.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<figure><img src=\"@source/code/website/definition/assets/http32.jpg\" alt=\"Http 漫画\" tabindex=\"0\" loading=\"lazy\"><figcaption>Http 漫画</figcaption></figure>\n<div class=\"hint-container info\">\n<p class=\"hint-container-title\">相关信息</p>\n<p>最新推出的 TLS 协议，是 SSL 3.0 协议的升级版，和 SSL 协议的大体原理是相同的。</p>\n</div>\n","tagOpen":"<template>","tagClose":"</template>"},"script":null,"scriptSetup":null,"scripts":[],"styles":[],"customBlocks":[]},"content":"\n## 什么是 HTTP 协议\n\nHTTP 协议全称 Hyper Text Transfer Protocol，翻译过来就是超文本传输协议，位于 TCP/IP 四层模型当中的应用层。\n\n![Http 漫画](./assets/http1.jpg)\n\nHTTP 协议通过 **请求/响应** 的方式，在客户端和服务端之间进行通信。\n\n![Http 漫画](./assets/http2.jpg)\n\n这一切看起来很美好，但是 HTTP 协议有一个致命的缺点: **不够安全**。\n\nHTTP 协议的信息传输完全以明文方式，不做任何加密，相当于是在网络上“裸奔”。这样会导致什么问题呢? 让我们打一个比方:\n\n小灰是客户端，小灰的同事小红是服务端，有一天小灰试图给小红发送请求。\n\n![Http 漫画](./assets/http3.jpg)\n\n但是，由于传输信息是明文，这个信息有可能被某个中间人恶意截获甚至篡改。这种行为叫做**中间人攻击**。\n\n![Http 漫画](./assets/http4.jpg)\n\n![Http 漫画](./assets/http5.jpg)\n\n![Http 漫画](./assets/http6.jpg)\n\n如何进行加密呢?\n\n小灰和小红可以事先约定一种**对称加密**方式，并且约定一个随机生成的密钥。后续的通信中，信息发送方都使用密钥对信息加密，而信息接收方通过同样的密钥对信息解密。\n\n![Http 漫画](./assets/http7.jpg)\n\n![Http 漫画](./assets/http8.jpg)\n\n这样做是不是就绝对安全了呢? 并不是。\n\n虽然我们在后续的通信中对明文进行了加密，但是第一次约定加密方式和密钥的通信仍然是明文，如果第一次通信就已经被拦截了，那么密钥就会泄露给中间人，中间人仍然可以解密后续所有的通信内容。\n\n![Http 漫画](./assets/http9.jpg)\n\n这可怎么办呢? 别担心，我们可以使用**非对称加密**，为密钥的传输做一层额外的保护。\n\n非对称加密的一组秘钥对中，包含一个公钥和一个私钥。明文既可以用公钥加密，用私钥解密；也可以用私钥加密，用公钥解密。\n\n在小灰和小红建立通信的时候，小红首先把自己的公钥 Key1 发给小灰:\n\n![Http 漫画](./assets/http10.jpg)\n\n收到小红的公钥以后，小灰自己生成一个用于对称加密的密钥 Key2，并且用刚才接收的公钥 Key1 对 Key2 进行加密(这里有点绕)，发送给小红:\n\n![Http 漫画](./assets/http11.jpg)\n\n小红利用自己非对称加密的私钥，解开了公钥 Key1 的加密，获得了 Key2 的内容。从此以后，两人就可以利用 Key2 进行对称加密的通信了。\n\n![Http 漫画](./assets/http12.jpg)\n\n在通信过程中，即使中间人在一开始就截获了公钥 Key1，由于不知道私钥是什么，也无从解密。\n\n![Http 漫画](./assets/http13.jpg)\n\n![Http 漫画](./assets/http14.jpg)\n\n是什么坏主意呢? 中间人虽然不知道小红的私钥是什么，但是在截获了小红的公钥 Key1 之后，却可以偷天换日，自己另外生成一对公钥私钥，把自己的公钥 Key3 发送给小灰。\n\n![Http 漫画](./assets/http15.jpg)\n\n小灰不知道公钥被偷偷换过，以为 Key3 就是小红的公钥。于是按照先前的流程，用 Key3 加密了自己生成的对称加密密钥 Key2，发送给小红。\n\n这一次通信再次被中间人截获，中间人先用自己的私钥解开了 Key3 的加密，获得 Key2，然后再用当初小红发来的 Key1 重新加密，再发给小红。\n\n![Http 漫画](./assets/http16.jpg)\n\n这样一来，两个人后续的通信尽管用 Key2 做了对称加密，但是中间人已经掌握了 Key2，所以可以轻松进行解密。\n\n![Http 漫画](./assets/http17.jpg)\n\n![Http 漫画](./assets/http18.jpg)\n\n是什么解决方案呢? 难道再把公钥进行一次加密吗? 这样只会陷入鸡生蛋蛋生鸡，永无止境的困局。\n\n这时候，我们有必要引入第三方，一个权威的证书颁发机构(CA)来解决。\n\n到底什么是证书呢? 证书包含如下信息:\n\n![Http 漫画](./assets/http19.jpg)\n\n为了便于说明，我们这里做了简化，只列出了一些关键信息。至于这些证书信息的用处，我们看看具体的通信流程就能够弄明白了。\n\n流程如下:\n\n1. 作为服务端的小红，首先把自己的公钥发给证书颁发机构，向证书颁发机构申请证书。\n\n   ![Http 漫画](./assets/http20.jpg)\n\n1. 证书颁发机构自己也有一对公钥私钥。机构利用自己的私钥来加密 Key1，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过机构的私钥加密。证书制作完成后，机构把证书发送给了服务端小红。\n\n   ![Http 漫画](./assets/http21.jpg)\n\n1. 当小灰向小红请求通信的时候，小红不再直接返回自己的公钥，而是把自己申请的证书返回给小灰。\n\n   ![Http 漫画](./assets/http22.jpg)\n\n1. 小灰收到证书以后，要做的第一件事情是验证证书的真伪。需要说明的是，各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥。所以小灰只需要知道是\n\n   哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书签名。\n\n   接下来，小灰按照同样的签名规则，自己也生成一个证书签名，如果两个签名一致，说明证书是有效的。\n\n   验证成功后，小灰就可以放心地再次利用机构公钥，解密出服务端小红的公钥 Key1。\n\n   ![Http 漫画](./assets/http23.jpg)\n\n1. 像之前一样，小灰生成自己的对称加密密钥 Key2，并且用服务端公钥 Key1 加密 Key2，发送给小红。\n\n   ![Http 漫画](./assets/http24.jpg)\n\n1. 最后，小红用自己的私钥解开加密，得到对称加密密钥 Key2。于是两人开始用 Key2 进行对称加密的通信。\n\n   ![Http 漫画](./assets/http25.jpg)\n\n在这样的流程下，我们不妨想一想，中间人是否还具有使坏的空间呢?\n\n![Http 漫画](./assets/http26.jpg)\n\n![Http 漫画](./assets/http27.jpg)\n\n![Http 漫画](./assets/http28.jpg)\n\n![Http 漫画](./assets/http29.jpg)\n\n![Http 漫画](./assets/http30.jpg)\n\n![Http 漫画](./assets/http31.jpg)\n\n![Http 漫画](./assets/http32.jpg)\n\n::: info\n\n最新推出的 TLS 协议，是 SSL 3.0 协议的升级版，和 SSL 协议的大体原理是相同的。\n\n:::\n","excerpt":"","title":"","headers":[{"level":2,"title":"什么是 HTTP 协议","slug":"什么是-http-协议","link":"#什么是-http-协议","children":[]}]}}
