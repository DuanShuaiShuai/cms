{"content":"<p>在小程序中所有页面的路由全部由框架进行管理。</p>\n<!-- more -->\n<h2 id=\"页面栈\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#页面栈\"><span>页面栈 <Badge text=\"重要\" type=\"error\" /></span></a></h2>\n<p>框架以栈的形式维护了当前的所有页面。当发生路由切换的时候，页面栈的表现如下:</p>\n<table>\n<thead>\n<tr>\n<th>路由方式</th>\n<th>页面栈表现</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>初始化</td>\n<td>新页面入栈</td>\n</tr>\n<tr>\n<td>打开新页面</td>\n<td>新页面入栈</td>\n</tr>\n<tr>\n<td>页面重定向</td>\n<td>当前页面出栈，新页面入栈</td>\n</tr>\n<tr>\n<td>页面返回</td>\n<td>页面不断出栈，直到目标返回页</td>\n</tr>\n<tr>\n<td>Tab 切换</td>\n<td>页面全部出栈，只留下新的 Tab 页面</td>\n</tr>\n<tr>\n<td>重加载</td>\n<td>页面全部出栈，只留下新的页面</td>\n</tr>\n</tbody>\n</table>\n<p>开发者可以使用 <code v-pre>getCurrentPages()</code> 函数获取当前页面栈。</p>\n<h2 id=\"路由方式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#路由方式\"><span>路由方式 <Badge text=\"重要\" type=\"error\" /></span></a></h2>\n<p>对于路由的触发方式以及页面生命周期函数如下:</p>\n<p>| 路由方式   | 触发时机                                                                        | 路由前页面           | 路由后页面     |\n| ---------- | ------------------------------------------------------------------------------- | -------------------- | -------------- | ------------------ |\n| 初始化     | 小程序打开的第一个页面                                                          |                      | onLoad, onShow |\n| 打开新页面 | 调用 API <code v-pre>wx.navigateTo</code><br />使用组件 <code v-pre>&lt;navigator open-type=&quot;navigateTo&quot;/&gt;</code>    | onHide               | onLoad, onShow |\n| 页面重定向 | 调用 API <code v-pre>wx.redirectTo</code><br />使用组件 <code v-pre>&lt;navigator open-type=&quot;redirectTo&quot;/&gt;</code>    | onUnload             | onLoad, onShow |\n| 页面返回   | 调用 API <code v-pre>wx.navigateBack</code><br />使用组件 <code v-pre>&lt;navigator open-type=&quot;navigateBack&quot;&gt;</code> | 用户按左上角返回按钮 | onUnload       | onShow             |\n| Tab 切换   | 调用 API <code v-pre>wx.switchTab</code><br />使用组件 <code v-pre>&lt;navigator open-type=&quot;switchTab&quot;/&gt;</code>      | 用户切换 Tab         |                | 各种情况请参考下表 |\n| 重启动     | 调用 API <code v-pre>wx.reLaunch</code><br />使用组件 <code v-pre>&lt;navigator open-type=&quot;reLaunch&quot;/&gt;</code>        | onUnload             | onLoad, onShow |</p>\n<p>Tab 切换对应的生命周期(以 A、B 页面为 Tabbar 页面，C 是从 A 页面打开的页面，D 页面是从 C 页面打开的页面为例):</p>\n<table>\n<thead>\n<tr>\n<th>当前页面</th>\n<th>路由后页面</th>\n<th>触发的生命周期(按顺序)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A</td>\n<td>A</td>\n<td>Nothing happened</td>\n</tr>\n<tr>\n<td>A</td>\n<td>B</td>\n<td>A.onHide(), B.onLoad(), B.onShow()</td>\n</tr>\n<tr>\n<td>A</td>\n<td>B(再次打开)</td>\n<td>A.onHide(), B.onShow()</td>\n</tr>\n<tr>\n<td>C</td>\n<td>A</td>\n<td>C.onUnload(), A.onShow()</td>\n</tr>\n<tr>\n<td>C</td>\n<td>B</td>\n<td>C.onUnload(), B.onLoad(), B.onShow()</td>\n</tr>\n<tr>\n<td>D</td>\n<td>B</td>\n<td>D.onUnload(), C.onUnload(), B.onLoad(), B.onShow()</td>\n</tr>\n<tr>\n<td>D(从转发进入)</td>\n<td>A</td>\n<td>D.onUnload(), A.onLoad(), A.onShow()</td>\n</tr>\n<tr>\n<td>D(从转发进入)</td>\n<td>B</td>\n<td>D.onUnload(), B.onLoad(), B.onShow()</td>\n</tr>\n</tbody>\n</table>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">提示</p>\n<ul>\n<li><code v-pre>navigateTo</code>, <code v-pre>redirectTo</code> 只能打开非 tabBar 页面。</li>\n<li><code v-pre>switchTab</code> 只能打开 tabBar 页面。</li>\n<li><code v-pre>reLaunch</code> 可以打开任意页面。</li>\n<li>页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。</li>\n<li>调用页面路由带的参数可以在目标页面的 <code v-pre>onLoad</code> 中获取。</li>\n</ul>\n</div>\n","env":{"base":"/","filePath":"/Users/carson/Desktop/Mister-Hope.github.io-main/src/code/mini-app/guide/service/route.md","filePathRelative":"code/mini-app/guide/service/route.md","frontmatter":{"date":"2020-10-09T00:00:00.000Z","title":"页面路由","icon":"router","category":"小程序"},"sfcBlocks":{"template":{"type":"template","content":"<template><p>在小程序中所有页面的路由全部由框架进行管理。</p>\n<!-- more -->\n<h2 id=\"页面栈\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#页面栈\"><span>页面栈 <Badge text=\"重要\" type=\"error\" /></span></a></h2>\n<p>框架以栈的形式维护了当前的所有页面。当发生路由切换的时候，页面栈的表现如下:</p>\n<table>\n<thead>\n<tr>\n<th>路由方式</th>\n<th>页面栈表现</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>初始化</td>\n<td>新页面入栈</td>\n</tr>\n<tr>\n<td>打开新页面</td>\n<td>新页面入栈</td>\n</tr>\n<tr>\n<td>页面重定向</td>\n<td>当前页面出栈，新页面入栈</td>\n</tr>\n<tr>\n<td>页面返回</td>\n<td>页面不断出栈，直到目标返回页</td>\n</tr>\n<tr>\n<td>Tab 切换</td>\n<td>页面全部出栈，只留下新的 Tab 页面</td>\n</tr>\n<tr>\n<td>重加载</td>\n<td>页面全部出栈，只留下新的页面</td>\n</tr>\n</tbody>\n</table>\n<p>开发者可以使用 <code v-pre>getCurrentPages()</code> 函数获取当前页面栈。</p>\n<h2 id=\"路由方式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#路由方式\"><span>路由方式 <Badge text=\"重要\" type=\"error\" /></span></a></h2>\n<p>对于路由的触发方式以及页面生命周期函数如下:</p>\n<p>| 路由方式   | 触发时机                                                                        | 路由前页面           | 路由后页面     |\n| ---------- | ------------------------------------------------------------------------------- | -------------------- | -------------- | ------------------ |\n| 初始化     | 小程序打开的第一个页面                                                          |                      | onLoad, onShow |\n| 打开新页面 | 调用 API <code v-pre>wx.navigateTo</code><br />使用组件 <code v-pre>&lt;navigator open-type=&quot;navigateTo&quot;/&gt;</code>    | onHide               | onLoad, onShow |\n| 页面重定向 | 调用 API <code v-pre>wx.redirectTo</code><br />使用组件 <code v-pre>&lt;navigator open-type=&quot;redirectTo&quot;/&gt;</code>    | onUnload             | onLoad, onShow |\n| 页面返回   | 调用 API <code v-pre>wx.navigateBack</code><br />使用组件 <code v-pre>&lt;navigator open-type=&quot;navigateBack&quot;&gt;</code> | 用户按左上角返回按钮 | onUnload       | onShow             |\n| Tab 切换   | 调用 API <code v-pre>wx.switchTab</code><br />使用组件 <code v-pre>&lt;navigator open-type=&quot;switchTab&quot;/&gt;</code>      | 用户切换 Tab         |                | 各种情况请参考下表 |\n| 重启动     | 调用 API <code v-pre>wx.reLaunch</code><br />使用组件 <code v-pre>&lt;navigator open-type=&quot;reLaunch&quot;/&gt;</code>        | onUnload             | onLoad, onShow |</p>\n<p>Tab 切换对应的生命周期(以 A、B 页面为 Tabbar 页面，C 是从 A 页面打开的页面，D 页面是从 C 页面打开的页面为例):</p>\n<table>\n<thead>\n<tr>\n<th>当前页面</th>\n<th>路由后页面</th>\n<th>触发的生命周期(按顺序)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A</td>\n<td>A</td>\n<td>Nothing happened</td>\n</tr>\n<tr>\n<td>A</td>\n<td>B</td>\n<td>A.onHide(), B.onLoad(), B.onShow()</td>\n</tr>\n<tr>\n<td>A</td>\n<td>B(再次打开)</td>\n<td>A.onHide(), B.onShow()</td>\n</tr>\n<tr>\n<td>C</td>\n<td>A</td>\n<td>C.onUnload(), A.onShow()</td>\n</tr>\n<tr>\n<td>C</td>\n<td>B</td>\n<td>C.onUnload(), B.onLoad(), B.onShow()</td>\n</tr>\n<tr>\n<td>D</td>\n<td>B</td>\n<td>D.onUnload(), C.onUnload(), B.onLoad(), B.onShow()</td>\n</tr>\n<tr>\n<td>D(从转发进入)</td>\n<td>A</td>\n<td>D.onUnload(), A.onLoad(), A.onShow()</td>\n</tr>\n<tr>\n<td>D(从转发进入)</td>\n<td>B</td>\n<td>D.onUnload(), B.onLoad(), B.onShow()</td>\n</tr>\n</tbody>\n</table>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">提示</p>\n<ul>\n<li><code v-pre>navigateTo</code>, <code v-pre>redirectTo</code> 只能打开非 tabBar 页面。</li>\n<li><code v-pre>switchTab</code> 只能打开 tabBar 页面。</li>\n<li><code v-pre>reLaunch</code> 可以打开任意页面。</li>\n<li>页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。</li>\n<li>调用页面路由带的参数可以在目标页面的 <code v-pre>onLoad</code> 中获取。</li>\n</ul>\n</div>\n</template>","contentStripped":"<p>在小程序中所有页面的路由全部由框架进行管理。</p>\n<!-- more -->\n<h2 id=\"页面栈\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#页面栈\"><span>页面栈 <Badge text=\"重要\" type=\"error\" /></span></a></h2>\n<p>框架以栈的形式维护了当前的所有页面。当发生路由切换的时候，页面栈的表现如下:</p>\n<table>\n<thead>\n<tr>\n<th>路由方式</th>\n<th>页面栈表现</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>初始化</td>\n<td>新页面入栈</td>\n</tr>\n<tr>\n<td>打开新页面</td>\n<td>新页面入栈</td>\n</tr>\n<tr>\n<td>页面重定向</td>\n<td>当前页面出栈，新页面入栈</td>\n</tr>\n<tr>\n<td>页面返回</td>\n<td>页面不断出栈，直到目标返回页</td>\n</tr>\n<tr>\n<td>Tab 切换</td>\n<td>页面全部出栈，只留下新的 Tab 页面</td>\n</tr>\n<tr>\n<td>重加载</td>\n<td>页面全部出栈，只留下新的页面</td>\n</tr>\n</tbody>\n</table>\n<p>开发者可以使用 <code v-pre>getCurrentPages()</code> 函数获取当前页面栈。</p>\n<h2 id=\"路由方式\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#路由方式\"><span>路由方式 <Badge text=\"重要\" type=\"error\" /></span></a></h2>\n<p>对于路由的触发方式以及页面生命周期函数如下:</p>\n<p>| 路由方式   | 触发时机                                                                        | 路由前页面           | 路由后页面     |\n| ---------- | ------------------------------------------------------------------------------- | -------------------- | -------------- | ------------------ |\n| 初始化     | 小程序打开的第一个页面                                                          |                      | onLoad, onShow |\n| 打开新页面 | 调用 API <code v-pre>wx.navigateTo</code><br />使用组件 <code v-pre>&lt;navigator open-type=&quot;navigateTo&quot;/&gt;</code>    | onHide               | onLoad, onShow |\n| 页面重定向 | 调用 API <code v-pre>wx.redirectTo</code><br />使用组件 <code v-pre>&lt;navigator open-type=&quot;redirectTo&quot;/&gt;</code>    | onUnload             | onLoad, onShow |\n| 页面返回   | 调用 API <code v-pre>wx.navigateBack</code><br />使用组件 <code v-pre>&lt;navigator open-type=&quot;navigateBack&quot;&gt;</code> | 用户按左上角返回按钮 | onUnload       | onShow             |\n| Tab 切换   | 调用 API <code v-pre>wx.switchTab</code><br />使用组件 <code v-pre>&lt;navigator open-type=&quot;switchTab&quot;/&gt;</code>      | 用户切换 Tab         |                | 各种情况请参考下表 |\n| 重启动     | 调用 API <code v-pre>wx.reLaunch</code><br />使用组件 <code v-pre>&lt;navigator open-type=&quot;reLaunch&quot;/&gt;</code>        | onUnload             | onLoad, onShow |</p>\n<p>Tab 切换对应的生命周期(以 A、B 页面为 Tabbar 页面，C 是从 A 页面打开的页面，D 页面是从 C 页面打开的页面为例):</p>\n<table>\n<thead>\n<tr>\n<th>当前页面</th>\n<th>路由后页面</th>\n<th>触发的生命周期(按顺序)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A</td>\n<td>A</td>\n<td>Nothing happened</td>\n</tr>\n<tr>\n<td>A</td>\n<td>B</td>\n<td>A.onHide(), B.onLoad(), B.onShow()</td>\n</tr>\n<tr>\n<td>A</td>\n<td>B(再次打开)</td>\n<td>A.onHide(), B.onShow()</td>\n</tr>\n<tr>\n<td>C</td>\n<td>A</td>\n<td>C.onUnload(), A.onShow()</td>\n</tr>\n<tr>\n<td>C</td>\n<td>B</td>\n<td>C.onUnload(), B.onLoad(), B.onShow()</td>\n</tr>\n<tr>\n<td>D</td>\n<td>B</td>\n<td>D.onUnload(), C.onUnload(), B.onLoad(), B.onShow()</td>\n</tr>\n<tr>\n<td>D(从转发进入)</td>\n<td>A</td>\n<td>D.onUnload(), A.onLoad(), A.onShow()</td>\n</tr>\n<tr>\n<td>D(从转发进入)</td>\n<td>B</td>\n<td>D.onUnload(), B.onLoad(), B.onShow()</td>\n</tr>\n</tbody>\n</table>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">提示</p>\n<ul>\n<li><code v-pre>navigateTo</code>, <code v-pre>redirectTo</code> 只能打开非 tabBar 页面。</li>\n<li><code v-pre>switchTab</code> 只能打开 tabBar 页面。</li>\n<li><code v-pre>reLaunch</code> 可以打开任意页面。</li>\n<li>页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。</li>\n<li>调用页面路由带的参数可以在目标页面的 <code v-pre>onLoad</code> 中获取。</li>\n</ul>\n</div>\n","tagOpen":"<template>","tagClose":"</template>"},"script":null,"scriptSetup":null,"scripts":[],"styles":[],"customBlocks":[]},"content":"\n在小程序中所有页面的路由全部由框架进行管理。\n\n<!-- more -->\n\n## 页面栈 <Badge text=\"重要\" type=\"error\" />\n\n框架以栈的形式维护了当前的所有页面。当发生路由切换的时候，页面栈的表现如下:\n\n| 路由方式   | 页面栈表现                        |\n| ---------- | --------------------------------- |\n| 初始化     | 新页面入栈                        |\n| 打开新页面 | 新页面入栈                        |\n| 页面重定向 | 当前页面出栈，新页面入栈          |\n| 页面返回   | 页面不断出栈，直到目标返回页      |\n| Tab 切换   | 页面全部出栈，只留下新的 Tab 页面 |\n| 重加载     | 页面全部出栈，只留下新的页面      |\n\n开发者可以使用 `getCurrentPages()` 函数获取当前页面栈。\n\n## 路由方式 <Badge text=\"重要\" type=\"error\" />\n\n对于路由的触发方式以及页面生命周期函数如下:\n\n| 路由方式   | 触发时机                                                                        | 路由前页面           | 路由后页面     |\n| ---------- | ------------------------------------------------------------------------------- | -------------------- | -------------- | ------------------ |\n| 初始化     | 小程序打开的第一个页面                                                          |                      | onLoad, onShow |\n| 打开新页面 | 调用 API `wx.navigateTo`<br />使用组件 `<navigator open-type=\"navigateTo\"/>`    | onHide               | onLoad, onShow |\n| 页面重定向 | 调用 API `wx.redirectTo`<br />使用组件 `<navigator open-type=\"redirectTo\"/>`    | onUnload             | onLoad, onShow |\n| 页面返回   | 调用 API `wx.navigateBack`<br />使用组件 `<navigator open-type=\"navigateBack\">` | 用户按左上角返回按钮 | onUnload       | onShow             |\n| Tab 切换   | 调用 API `wx.switchTab`<br />使用组件 `<navigator open-type=\"switchTab\"/>`      | 用户切换 Tab         |                | 各种情况请参考下表 |\n| 重启动     | 调用 API `wx.reLaunch`<br />使用组件 `<navigator open-type=\"reLaunch\"/>`        | onUnload             | onLoad, onShow |\n\nTab 切换对应的生命周期(以 A、B 页面为 Tabbar 页面，C 是从 A 页面打开的页面，D 页面是从 C 页面打开的页面为例):\n\n| 当前页面      | 路由后页面  | 触发的生命周期(按顺序)                             |\n| ------------- | ----------- | -------------------------------------------------- |\n| A             | A           | Nothing happened                                   |\n| A             | B           | A.onHide(), B.onLoad(), B.onShow()                 |\n| A             | B(再次打开) | A.onHide(), B.onShow()                             |\n| C             | A           | C.onUnload(), A.onShow()                           |\n| C             | B           | C.onUnload(), B.onLoad(), B.onShow()               |\n| D             | B           | D.onUnload(), C.onUnload(), B.onLoad(), B.onShow() |\n| D(从转发进入) | A           | D.onUnload(), A.onLoad(), A.onShow()               |\n| D(从转发进入) | B           | D.onUnload(), B.onLoad(), B.onShow()               |\n\n::: tip\n\n- `navigateTo`, `redirectTo` 只能打开非 tabBar 页面。\n- `switchTab` 只能打开 tabBar 页面。\n- `reLaunch` 可以打开任意页面。\n- 页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。\n- 调用页面路由带的参数可以在目标页面的 `onLoad` 中获取。\n\n:::\n","excerpt":"","title":"","headers":[{"level":2,"title":"页面栈","slug":"页面栈","link":"#页面栈","children":[]},{"level":2,"title":"路由方式","slug":"路由方式","link":"#路由方式","children":[]}]}}
