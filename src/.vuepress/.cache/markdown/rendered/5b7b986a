{"content":"<h1 id=\"dirname、-filename-和-process-cwd-三者的区别\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#dirname、-filename-和-process-cwd-三者的区别\"><span><code v-pre>__dirname</code>、<code v-pre>__filename</code> 和 <code v-pre>process.cwd()</code> 三者的区别</span></a></h1>\n<ol>\n<li>\n<p><code v-pre>process.cwd()</code> 方法返回 Node.js 进程当前工作的目录</p>\n<p>例: 我在 <code v-pre>F:\\自己的文件\\自己在网上学习的知识点\\node学习\\node-API\\process</code> 这个文件加下面创建了一个 test.js 在该 js 文件中写下下面的代码，然后右键 <code v-pre>run test.js</code></p>\n<div class=\"language-js\" data-highlighter=\"shiki\" data-ext=\"js\" data-title=\"js\" style=\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\"><pre v-pre class=\"shiki shiki-themes one-light one-dark-pro vp-code\"><code><span class=\"line\"><span style=\"--shiki-light:#A626A4;--shiki-dark:#C678DD\">const</span><span style=\"--shiki-light:#986801;--shiki-dark:#E5C07B\"> cwd</span><span style=\"--shiki-light:#0184BC;--shiki-dark:#56B6C2\"> =</span><span style=\"--shiki-light:#383A42;--shiki-dark:#E5C07B\"> process</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">.</span><span style=\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\">cwd</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">();</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#383A42;--shiki-dark:#E5C07B\">console</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">.</span><span style=\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\">log</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">(</span><span style=\"--shiki-light:#383A42;--shiki-dark:#E06C75\">cwd</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">);</span></span></code></pre>\n</div><p>输出如下 <code v-pre>F:\\自己的文件\\自己在网上学习的知识点\\node学习\\node-API\\process</code></p>\n</li>\n<li>\n<p><code v-pre>__dirname</code> 是 Node.js 的一个全局变量，获得当前文件所在目录的完整目录名</p>\n<p>还在上面的 js 文件中输入一下代码</p>\n<div class=\"language-js\" data-highlighter=\"shiki\" data-ext=\"js\" data-title=\"js\" style=\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\"><pre v-pre class=\"shiki shiki-themes one-light one-dark-pro vp-code\"><code><span class=\"line\"><span style=\"--shiki-light:#383A42;--shiki-dark:#E5C07B\">console</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">.</span><span style=\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\">log</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">(</span><span style=\"--shiki-light:#383A42;--shiki-dark:#E06C75\">__dirname</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">);</span></span></code></pre>\n</div><p>输出如下 <code v-pre>F:\\自己的文件\\自己在网上学习的知识点\\node学习\\node-API\\process</code></p>\n<p>现在一看感觉上面两个方法是一样的，其实不是。node.js 进程当前工作的目录有可能不是该文件所在目录的完整目录。例如: 我用 <code v-pre>node webpack ..</code> 打包了一个应用程序，\n我用这个应用程序可以生产出一套完整的页面架构，在应用程序的配置文件中 console.log(cwd)\n在完整的这个页面架构中执行启动这个项目的命令，则对应的 cwd 就是当前项目所在的绝对路径,而不是应用程序的路径</p>\n</li>\n<li>\n<p><code v-pre>__filename</code> 也是 Node.js 的全局变量 Node.js 中，在任何模块文件内部，可以使用 <code v-pre>__filename</code> 变量获取当前模块文件的带有完整绝对路径的文件名</p>\n</li>\n</ol>\n<div class=\"language-js\" data-highlighter=\"shiki\" data-ext=\"js\" data-title=\"js\" style=\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\"><pre v-pre class=\"shiki shiki-themes one-light one-dark-pro vp-code\"><code><span class=\"line\"><span style=\"--shiki-light:#383A42;--shiki-dark:#E5C07B\">console</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">.</span><span style=\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\">log</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">(</span><span style=\"--shiki-light:#383A42;--shiki-dark:#E06C75\">__filename</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">);</span></span></code></pre>\n</div><p>输出 <code v-pre>F:\\自己的文件\\自己在网上学习的知识点\\node 学习\\node-API\\process\\test.js</code></p>\n","env":{"base":"/","filePath":"/Users/carson/Desktop/Mister-Hope.github.io-main/src/note/node-js/current-path.md","filePathRelative":"note/node-js/current-path.md","frontmatter":{"icon":"nodeJS","date":"2019-09-10T00:00:00.000Z","tag":["Node.js"]},"sfcBlocks":{"template":{"type":"template","content":"<template><h1 id=\"dirname、-filename-和-process-cwd-三者的区别\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#dirname、-filename-和-process-cwd-三者的区别\"><span><code v-pre>__dirname</code>、<code v-pre>__filename</code> 和 <code v-pre>process.cwd()</code> 三者的区别</span></a></h1>\n<ol>\n<li>\n<p><code v-pre>process.cwd()</code> 方法返回 Node.js 进程当前工作的目录</p>\n<p>例: 我在 <code v-pre>F:\\自己的文件\\自己在网上学习的知识点\\node学习\\node-API\\process</code> 这个文件加下面创建了一个 test.js 在该 js 文件中写下下面的代码，然后右键 <code v-pre>run test.js</code></p>\n<div class=\"language-js\" data-highlighter=\"shiki\" data-ext=\"js\" data-title=\"js\" style=\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\"><pre v-pre class=\"shiki shiki-themes one-light one-dark-pro vp-code\"><code><span class=\"line\"><span style=\"--shiki-light:#A626A4;--shiki-dark:#C678DD\">const</span><span style=\"--shiki-light:#986801;--shiki-dark:#E5C07B\"> cwd</span><span style=\"--shiki-light:#0184BC;--shiki-dark:#56B6C2\"> =</span><span style=\"--shiki-light:#383A42;--shiki-dark:#E5C07B\"> process</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">.</span><span style=\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\">cwd</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">();</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#383A42;--shiki-dark:#E5C07B\">console</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">.</span><span style=\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\">log</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">(</span><span style=\"--shiki-light:#383A42;--shiki-dark:#E06C75\">cwd</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">);</span></span></code></pre>\n</div><p>输出如下 <code v-pre>F:\\自己的文件\\自己在网上学习的知识点\\node学习\\node-API\\process</code></p>\n</li>\n<li>\n<p><code v-pre>__dirname</code> 是 Node.js 的一个全局变量，获得当前文件所在目录的完整目录名</p>\n<p>还在上面的 js 文件中输入一下代码</p>\n<div class=\"language-js\" data-highlighter=\"shiki\" data-ext=\"js\" data-title=\"js\" style=\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\"><pre v-pre class=\"shiki shiki-themes one-light one-dark-pro vp-code\"><code><span class=\"line\"><span style=\"--shiki-light:#383A42;--shiki-dark:#E5C07B\">console</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">.</span><span style=\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\">log</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">(</span><span style=\"--shiki-light:#383A42;--shiki-dark:#E06C75\">__dirname</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">);</span></span></code></pre>\n</div><p>输出如下 <code v-pre>F:\\自己的文件\\自己在网上学习的知识点\\node学习\\node-API\\process</code></p>\n<p>现在一看感觉上面两个方法是一样的，其实不是。node.js 进程当前工作的目录有可能不是该文件所在目录的完整目录。例如: 我用 <code v-pre>node webpack ..</code> 打包了一个应用程序，\n我用这个应用程序可以生产出一套完整的页面架构，在应用程序的配置文件中 console.log(cwd)\n在完整的这个页面架构中执行启动这个项目的命令，则对应的 cwd 就是当前项目所在的绝对路径,而不是应用程序的路径</p>\n</li>\n<li>\n<p><code v-pre>__filename</code> 也是 Node.js 的全局变量 Node.js 中，在任何模块文件内部，可以使用 <code v-pre>__filename</code> 变量获取当前模块文件的带有完整绝对路径的文件名</p>\n</li>\n</ol>\n<div class=\"language-js\" data-highlighter=\"shiki\" data-ext=\"js\" data-title=\"js\" style=\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\"><pre v-pre class=\"shiki shiki-themes one-light one-dark-pro vp-code\"><code><span class=\"line\"><span style=\"--shiki-light:#383A42;--shiki-dark:#E5C07B\">console</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">.</span><span style=\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\">log</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">(</span><span style=\"--shiki-light:#383A42;--shiki-dark:#E06C75\">__filename</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">);</span></span></code></pre>\n</div><p>输出 <code v-pre>F:\\自己的文件\\自己在网上学习的知识点\\node 学习\\node-API\\process\\test.js</code></p>\n</template>","contentStripped":"<h1 id=\"dirname、-filename-和-process-cwd-三者的区别\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#dirname、-filename-和-process-cwd-三者的区别\"><span><code v-pre>__dirname</code>、<code v-pre>__filename</code> 和 <code v-pre>process.cwd()</code> 三者的区别</span></a></h1>\n<ol>\n<li>\n<p><code v-pre>process.cwd()</code> 方法返回 Node.js 进程当前工作的目录</p>\n<p>例: 我在 <code v-pre>F:\\自己的文件\\自己在网上学习的知识点\\node学习\\node-API\\process</code> 这个文件加下面创建了一个 test.js 在该 js 文件中写下下面的代码，然后右键 <code v-pre>run test.js</code></p>\n<div class=\"language-js\" data-highlighter=\"shiki\" data-ext=\"js\" data-title=\"js\" style=\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\"><pre v-pre class=\"shiki shiki-themes one-light one-dark-pro vp-code\"><code><span class=\"line\"><span style=\"--shiki-light:#A626A4;--shiki-dark:#C678DD\">const</span><span style=\"--shiki-light:#986801;--shiki-dark:#E5C07B\"> cwd</span><span style=\"--shiki-light:#0184BC;--shiki-dark:#56B6C2\"> =</span><span style=\"--shiki-light:#383A42;--shiki-dark:#E5C07B\"> process</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">.</span><span style=\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\">cwd</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">();</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#383A42;--shiki-dark:#E5C07B\">console</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">.</span><span style=\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\">log</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">(</span><span style=\"--shiki-light:#383A42;--shiki-dark:#E06C75\">cwd</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">);</span></span></code></pre>\n</div><p>输出如下 <code v-pre>F:\\自己的文件\\自己在网上学习的知识点\\node学习\\node-API\\process</code></p>\n</li>\n<li>\n<p><code v-pre>__dirname</code> 是 Node.js 的一个全局变量，获得当前文件所在目录的完整目录名</p>\n<p>还在上面的 js 文件中输入一下代码</p>\n<div class=\"language-js\" data-highlighter=\"shiki\" data-ext=\"js\" data-title=\"js\" style=\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\"><pre v-pre class=\"shiki shiki-themes one-light one-dark-pro vp-code\"><code><span class=\"line\"><span style=\"--shiki-light:#383A42;--shiki-dark:#E5C07B\">console</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">.</span><span style=\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\">log</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">(</span><span style=\"--shiki-light:#383A42;--shiki-dark:#E06C75\">__dirname</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">);</span></span></code></pre>\n</div><p>输出如下 <code v-pre>F:\\自己的文件\\自己在网上学习的知识点\\node学习\\node-API\\process</code></p>\n<p>现在一看感觉上面两个方法是一样的，其实不是。node.js 进程当前工作的目录有可能不是该文件所在目录的完整目录。例如: 我用 <code v-pre>node webpack ..</code> 打包了一个应用程序，\n我用这个应用程序可以生产出一套完整的页面架构，在应用程序的配置文件中 console.log(cwd)\n在完整的这个页面架构中执行启动这个项目的命令，则对应的 cwd 就是当前项目所在的绝对路径,而不是应用程序的路径</p>\n</li>\n<li>\n<p><code v-pre>__filename</code> 也是 Node.js 的全局变量 Node.js 中，在任何模块文件内部，可以使用 <code v-pre>__filename</code> 变量获取当前模块文件的带有完整绝对路径的文件名</p>\n</li>\n</ol>\n<div class=\"language-js\" data-highlighter=\"shiki\" data-ext=\"js\" data-title=\"js\" style=\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\"><pre v-pre class=\"shiki shiki-themes one-light one-dark-pro vp-code\"><code><span class=\"line\"><span style=\"--shiki-light:#383A42;--shiki-dark:#E5C07B\">console</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">.</span><span style=\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\">log</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">(</span><span style=\"--shiki-light:#383A42;--shiki-dark:#E06C75\">__filename</span><span style=\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\">);</span></span></code></pre>\n</div><p>输出 <code v-pre>F:\\自己的文件\\自己在网上学习的知识点\\node 学习\\node-API\\process\\test.js</code></p>\n","tagOpen":"<template>","tagClose":"</template>"},"script":null,"scriptSetup":null,"scripts":[],"styles":[],"customBlocks":[]},"content":"\n# `__dirname`、`__filename` 和 `process.cwd()` 三者的区别\n\n1. `process.cwd()` 方法返回 Node.js 进程当前工作的目录\n\n   例: 我在 `F:\\自己的文件\\自己在网上学习的知识点\\node学习\\node-API\\process` 这个文件加下面创建了一个 test.js 在该 js 文件中写下下面的代码，然后右键 `run test.js`\n\n   ```js\n   const cwd = process.cwd();\n   console.log(cwd);\n   ```\n\n   输出如下 `F:\\自己的文件\\自己在网上学习的知识点\\node学习\\node-API\\process`\n\n1. `__dirname` 是 Node.js 的一个全局变量，获得当前文件所在目录的完整目录名\n\n   还在上面的 js 文件中输入一下代码\n\n   ```js\n   console.log(__dirname);\n   ```\n\n   输出如下 `F:\\自己的文件\\自己在网上学习的知识点\\node学习\\node-API\\process`\n\n   现在一看感觉上面两个方法是一样的，其实不是。node.js 进程当前工作的目录有可能不是该文件所在目录的完整目录。例如: 我用 `node webpack ..` 打包了一个应用程序，\n   我用这个应用程序可以生产出一套完整的页面架构，在应用程序的配置文件中 console.log(cwd)\n   在完整的这个页面架构中执行启动这个项目的命令，则对应的 cwd 就是当前项目所在的绝对路径,而不是应用程序的路径\n\n1. `__filename` 也是 Node.js 的全局变量 Node.js 中，在任何模块文件内部，可以使用 `__filename` 变量获取当前模块文件的带有完整绝对路径的文件名\n\n```js\nconsole.log(__filename);\n```\n\n输出 `F:\\自己的文件\\自己在网上学习的知识点\\node 学习\\node-API\\process\\test.js`\n","excerpt":"","title":"__dirname、__filename 和 process.cwd() 三者的区别","headers":[]}}
